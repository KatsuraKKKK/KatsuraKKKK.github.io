{
  "title": "Spring scope",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; white-space: normal;\"><p>现代对象设计主张“组合优于继承”。总之无论组合还是继承，对象都成了涉及多个类的复合结构。</p><p>“对象的有效范围”，是指对象从创建到丢弃(不再引用)的这段时间，不包括等待被GC销毁的时间。可以近似认为是对象的生命期。</p><p>单例对象(Singleton)的有效范围几乎是整个应用的开启时间，Socket的有效范围通常是网络连接的持续时间，而一个临时的Integer则可能瞬间就被丢弃了。Let&apos;s 注意，不同范围的对象/类，不能随意地组合/继承在一起。</p><h3>1. 不同范围的对象避免打包在一起</h3><p>(代码有点多，如果嫌烦可以跳过1.先看2.)</p><p>反面教材：我们来看一个客户端程序，它通过socket与某个服务器保持通信，不断发消息并收取响应。</p><pre><code>public class Communication {\n  private Topic topic;\n  private Socket socket;\n\n  public Communication(String host, int port) {\n    socket = new Socket(host, port);\n  }\n  public void close() {\n    socket.close();\n  }\n  public void setTopic(Topic topic) {\n    this.topic = topic;\n  }\n  public String sendReceive(String msg) {\n    return sendRecv_(topic, msg);\n  }\n  private String sendRecv_(Topic topic, String msg) {\n    ... // 具体处理\n  }\n}\n</code></pre><p>我们有两个主题(topic) A和B，以不同主题发的消息，服务器会做不同处理。我们一会儿用主题A发消息，一会用主题B发消息。代码如下：</p><pre><code>Communication comm = new Communication(host, port);\ncomm.setTopic(A);\ncomm.sendReceive(&quot;Hello!&quot;);\ncomm.sendReceive(&quot;How are you?&quot;);\n\ncomm.setTopic(B);\ncomm.sendReceive(&quot;Good morning!&quot;);\ncomm.sendReceive(&quot;Let&apos;s begin&quot;);\n\ncomm.sendTopic(A);\ncomm.sendReceive(&quot;How old are you?&quot;);\n</code></pre><p>切换来切换去，真麻烦。如果你不嫌麻烦，假设给Communication再加一个域&quot;config&quot;，平均每发100条消息，要切换一次config，平均每发10条消息，要切换一次topic，还是交替进行，烦不烦！</p><p>再想想，<strong>如果多个线程在使用comm对象呢？</strong> 呵呵呵，完蛋了。</p><p>Communication的有效范围与socket一致，而topic的有效范围就小于socket了，因此topic就不该放在这个类里。虽然sendReceive()可以少填一个参数，看似方便，但是引发了更多麻烦。<br/><strong>对于继承也是同理，父类和子类应当有相同的有效范围。</strong></p><p>所以还是这么写吧:</p><pre><code>comm.sendReceive(A, &quot;Hello!&quot;);\ncomm.sendReceive(A, &quot;How are you?&quot;);\ncomm.sendReceive(B, &quot;Good morning!&quot;);\n</code></pre><blockquote><p>稍微有点麻烦呢</p></blockquote><p>或者这么写：</p><pre><code>class CommByTopic {\n  private Communication comm;\n  private Topic topic;\n  // 构造函数省略\n  public String sendReceive(String msg) {\n    return comm.sendReceive(topic, msg);\n  }\n}\n\nCommByTopic onA = new CommByTopic(comm, A);\nonA.sendReceive(msg);\nonB.sendReceive(msg);\n</code></pre><blockquote><p>缺点是comm关闭后要注意不能继续使用onA。所以不要长时间持有onA对象，最好能局限在方法作用域内。</p></blockquote><p>或者试试简洁的lamda~</p><p>Lamda in Java 8:</p><pre><code>Function&lt;String, String&gt; onA = msg -&gt; comm.sendReceive(A, msg);\nonA.apply(&quot;Hello!&quot;);\nonA.apply(&quot;How are you?&quot;);\n</code></pre><p>Lamda in Scala:</p><pre><code>val onA: String =&gt; String = comm.sendReceive(A, _)\nonA(&quot;Hello!&quot;)\nonA(&quot;How are you?&quot;)\n\n// 柯里化的写法 val onA = comm.sendReceive(A) _</code></pre><h3>2. 大范围对象不要持有小范围对象</h3><p>上面说的comm就是大范围对象，socket也是大范围对象，topic是小范围对象。它们生命长短不同。</p><p>如果大范围对象持有了小范围对象，你就要疲于切换，甚至担心线程安全性。反过来，小范围对象持有大范围对象，就好了。当然了，持有相同范围的对象也是好的。</p><p>对运行于IoC容器的程序尤其明显。来溜一段基于Spring MVC的应用代码：</p><pre><code>@Component@Scope(&quot;singleton&quot;) //单例对象public class Manager {\n  @Autowired\n  private Account account;\n\n  public void freezeAccount() {\n    account.freeze();\n    merge(account);\n  }\n}\n\n@Component@Scope(&quot;request&quot;) //request范围的对象public class Account {\n  ...\n}\n</code></pre><p>这样的代码在系统启动时就崩了，因为account还没出现。就算你给Manager标上<a href=\"http://segmentfault.com/u/lazy\">@Lazy</a> (延迟初始化)，让它在账户A发来请求时才初始化，它也只能正确处理这次的请求。下次账户B再来请求时，它还是使用上次的A的account来操作，而不会用B的account。呵呵呵，完蛋了。<br/>\n同理，session级的对象不要持有request级的对象。</p><p>对于Servlet和Filter也是如此，它们是近似于单例的对象，让它们持有一些配置数据和常量就行了，如果让它们持有当前的userId，也很危险。</p><p><strong>再提醒一下，其实小范围对象持有大范围对象也不要滥用，一不小心就会让对象承担过多职责，有过多依赖。设计要从职责出发。</strong></p><h3>结语</h3><p>之所以要从“有效范围”的角度谈对象设计的问题，就是想给大家提供一个明确可操作的分析视角，这可比“设计哲学”容易多了。</p><div>不过光会这个还不够，知识要全面。</div><div><br/></div><div><br/></div><div>http://segmentfault.com/q/1010000000716335/a-1020000000716845</div><div><br/></div></div>"
    }
  ]
}