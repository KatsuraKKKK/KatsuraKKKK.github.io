{
  "title": "jstat",
  "cells": [
    {
      "type": "text",
      "data": "<div>/\\*\\*</div><div><br></div><div>\\* 转载请注明作者longdick http://longdick.iteye.com</div><div><br></div><div>\\*</div><div><br></div><div>\\*/</div><div><br></div><div>**先看一下JVM的内存模型：**</div><div><br></div><div>![](quiver-image-url/703C99A98B41AADE840DDA512FC5309D.png)</div><div><br></div><div>**从大的方面来讲，JVM的内存模型分为两大块：**</div><div><br></div><div>永久区内存（ Permanent space ）和堆内存（heap space）。</div><div><br></div><div>栈内存（stack space）一般都不归在JVM内存模型中，因为栈内存属于线程级别。</div><div><br></div><div>每个线程都有个独立的栈内存空间。</div><div><br></div><div>Permanent space里存放加载的Class类级对象如class本身，method，field等等。</div><div><br></div><div>heap space主要存放对象实例和数组。</div><div><br></div><div>heap space由Old Generation和New Generation组成，Old Generation存放生命周期长久的实例对象，而新的对象实例一般放在New Generation。</div><div><br></div><div>New Generation还可以再分为Eden区(圣经中的伊甸园)、和Survivor区，新的对象实例总是首先放在Eden区，Survivor区作为Eden区和Old区的缓冲，可以向Old区转移活动的对象实例。</div><div><br></div><div>**下图是JVM在内存空间（堆空间）中申请新对象过程的活动图（点击看大图）：**</div><div>![](quiver-image-url/4A64DC30CBEE1916B6B372328EC9524F.jpg)</div><div><br></div><div>没错，我们常见的OOM（out of memory）内存溢出异常，就是堆内存空间不足以存放新对象实例时导致。</div><div><br></div><div>永久区内存溢出相对少见，一般是由于需要加载海量的Class数据，超过了非堆内存的容量导致。通常出现在Web应用刚刚启动时，因此Web应用推荐使用预加载机制，方便在部署时就发现并解决该问题。</div><div><br></div><div>栈内存也会溢出，但是更加少见。</div><div><br></div><div>**堆内存优化：**</div><div><br></div><div>调整JVM启动参数-Xms -Xmx -XX:newSize -XX:MaxNewSize，如调整初始堆内存和最大对内存 -Xms256M -Xmx512M。 或者调整初始New Generation的初始内存和最大内存 -XX:newSize=128M -XX:MaxNewSize=128M。</div><div><br></div><div>**永久区内存优化：**</div><div><br></div><div>调整PermSize参数 如 -XX:PermSize=256M -XX:MaxPermSize=512M。</div><div><br></div><div>**栈内存优化：**</div><div><br></div><div>调整每个线程的栈内存容量 如 -Xss2048K</div><div><br></div><div>&nbsp;业界有很多强大的java profile的工具，比如Jporfiler，yourkit，这些收费的东西我就不想说了，想说的是，其实java自己就提供了很多内存监控的小工具，下面列举的工具只是一小部分，仔细研究下jdk的工具，还是蛮有意思的呢：）</div><div><br></div><div>***1：gc日志输出***</div><div><br></div><div>&nbsp;在jvm启动参数中加入 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCApplicationStopedTime，jvm将会按照这些参数顺序输出gc概要信息，详细信息，gc时间信息，gc造成 的应用暂停时间。如果在刚才的参数后面加入参数 -Xloggc:文件路径，gc信息将会输出到指定的文件中。其他参数还有</div><div><br></div><div>-verbose:gc和-XX:+PrintTenuringDistribution等。</div><div><br></div><div>**2：jconsole**</div><div><br></div><div>&nbsp;jconsole是jdk自带的一个内存分析工具，它提供了图形界面。可以查看到被监控的jvm的内存信息，线程信息，类加载信息，MBean信息。</div><div><br></div><div>&nbsp;jconsole位于jdk目录下的bin目录，在windows下是jconsole.exe，在unix和linux下是 jconsole.sh，jconsole可以监控本地应用，也可以监控远程应用。 要监控本地应用，执行jconsole pid，pid就是运行的java进程id，如果不带上pid参数，则执行jconsole命令后，会看到一个对话框弹出，上面列出了本地的java进 程，可以选择一个进行监控。如果要远程监控，则要在远程服务器的jvm参数里加入一些东西，因为jconsole的远程监控基于jmx的，关于 jconsole详细用法，请见专门介绍jconsle的文章，我也会在博客里专门详细介绍jconsole。</div><div><br></div><div>***3:jviusalvm***</div><div><br></div><div>&nbsp;在JDK6 update 7之后，jdk推出了另外一个工具:jvisualvm,java可视化虚拟机，它不但提供了jconsole类似的功能，还提供了jvm内存和cpu实时诊断，还有手动dump出jvm内存情况，手动执行gc。</div><div><br></div><div>&nbsp;和jconsole一样，运行jviusalvm，在jdk的bin目录下执行jviusalvm，windows下是jviusalvm.exe,linux和unix下是jviusalvm.sh。</div><div><br></div><div>***4：jmap***</div><div><br></div><div>&nbsp;jmap是jdk自带的jvm内存分析的工具，位于jdk的bin目录。jdk1.6中jmap命令用法：</div><div><br></div><div>Html代码 [![收藏代码](quiver-image-url/55EB9A99292517E853B6A4F5EF4C4E57)](http://blog.csdn.net/yaowj2/article/details/7107818 \"收藏这段代码\")</div><div><br></div><div>1. Usage:</div><div>2. jmap -histo \\<pid\\> (to connect to running process and print histogram of java object heap</div><div>3. jmap -dump:\\<dump-options\\> \\<pid\\> (to connect to running process and dump java heap)</div><div>4. dump-options: format=b binary default file=\\<file\\></div><div>5. dump heap to \\<file\\></div><div>6. Example: jmap -dump:format=b,file=heap.bin \\<pid\\></div><div><br></div><div>&nbsp;jmap -histo \\<pid\\>在屏幕上显示出指定pid的jvm内存状况。以我本机为例，执行该命令，屏幕显示：</div><div><br></div><div>Html代码 [![收藏代码](quiver-image-url/55EB9A99292517E853B6A4F5EF4C4E57)](http://blog.csdn.net/yaowj2/article/details/7107818 \"收藏这段代码\")</div><div><br></div><div>1. 1: 24206 2791864 \\< constMethodKlass \\></div><div>2. 2: 22371 2145216 [C</div><div>3. 3: 24206 1940648 \\< methodKlass \\></div><div>4. 4: 1951 1364496 \\< constantPoolKlass \\></div><div>5. 5: 26543 1282560 \\< symbolKlass \\></div><div>6. 6: 6377 1081744 [B</div><div>7. 7: 1793 909688 \\< constantPoolCacheKlass \\></div><div>8. 8: 1471 614624 \\< instanceKlassKlass \\></div><div>9. 9: 14581 548336 [Ljava.lang.Object;</div><div>10. 10: 3863 513640 [I</div><div>11. 11: 20677 496248 java.lang.String</div><div>12. 12: 3621 312776 [Ljava.util.HashMap$Entry;</div><div>13. 13: 3335 266800 java.lang.reflect.Method</div><div>14. 14: 8256 264192 java.io.ObjectStreamClass$WeakClassKey</div><div>15. 15: 7066 226112 java.util.TreeMap$Entry</div><div>16. 16: 2355 173304 [S</div><div>17. 17: 1687 161952 java.lang.Class</div><div>18. 18: 2769 150112 [[I</div><div>19. 19: 3563 142520 java.util.HashMap</div><div>20. 20: 5562 133488 java.util.HashMap$Entry</div><div>21. Total 239019 17140408</div><div><br></div><div>&nbsp;为了方便查看，我删掉了一些行。从上面的信息很容易看出，\\#instance指的是对象数量，\\#bytes指的是这些对象占用的内存大小，class name指的是对象类型。</div><div><br></div><div>&nbsp;再看jmap的dump选项，这个选项是将jvm的堆中内存信息输出到一个文件中，在我本机执行</div><div><br></div><div>jmap -dump:file=c:\\\\dump.txt 340 </div><div><br></div><div>注意340是我本机的java进程pid，dump出来的文件比较大有10几M，而且我只是 开了tomcat，跑了一个很简单的应用，且没有任何访问，可以想象，大型繁忙的服务器上，dump出来的文件该有多大。需要知道的是，dump出来的文 件信息是很原始的，绝不适合人直接观看，而jmap -histo显示的内容又太简单，例如只显示某些类型的对象占用多大内存，以及这些对象的数量，但是没有更详细的信息，例如这些对象分别是由谁创建的。那 这么说，dump出来的文件有什么用呢？当然有用，因为有专门分析jvm的内存dump文件的工具。</div><div><br></div><div>*</div><div>*</div><div><br></div><div>***5：jhat***</div><div><br></div><div>&nbsp;上面说了，有很多工具都能分析jvm的内存dump文件，jhat就是sun jdk6及以上版本自带的工具，位于jdk的bin目录，执行 jhat -J -Xmx512m [file] ，file就是dump文件路径。jhat内置一个简单的web服务器，此命令执行后，jhat在命令行里显示分析结果的访问地址，可以用 -port选项指定端口，具体用法可以执行jhat -heap查看帮助信息。访问指定地址后，就能看到页面上显示的信息，比jmap -histo命令显示的丰富得多，更为详细。</div><div><br></div><div>**6：eclipse内存分析器**</div><div><br></div><div>&nbsp;上面说了jhat，它能分析jvm的dump文件，但是全部是文字显示，eclipse memory analyzer，是一个eclipse提供用于分析jvm 堆dump的插件，网址为 [http://www.eclipse.org/mat ](http://www.eclipse.org/mat),它的分析速度比jhat快，分析结果是图形界面显示，比jhat的可读性更高。其实jvisualvm也可以分析dump文件，也是有图形界面显示的。</div><div><br></div><div>**7：jstat**</div><div><br></div><div>&nbsp;如果说jmap倾向于分析jvm内存中对象信息的话，那么jsta就是倾向于分析jvm内存的gc情况。都是jvm内存分析工具，但显然，它们是从不同维 度来分析的。jsat常用的参数有很多，如 -gc,-gcutil,-gccause，这些选项具体作用可查看jsat帮助信息，我经常用-gcutil，这个参数的作用不断的显示当前指定的 jvm内存的垃圾收集的信息。</div><div><br></div><div>&nbsp;我在本机执行 jstat -gcutil 340 10000，这个命令是每个10秒钟输出一次jvm的gc信息，10000指的是间隔时间为10000毫秒。屏幕上显示如下信息（我只取了第一行，因为是 按的一定频率显示，所以实际执行的时候，会有很多行）：</div><div><br></div><div>&nbsp;S0 S1 E O P YGC YGCT FGC FGCT GCT </div><div>&nbsp;54.62 0.00 42.87 43.52 86.24 1792 5.093 33 7.670 12.763</div><div><br></div><div>&nbsp;额。。。怎么说呢，要看懂这些信息代表什么意思，还必须对jvm的gc机制有一定的了解才行啊。其实如果对sun的 hot spot jvm的gc比较了解的人，应该很容易看懂这些信息，但是不清楚gc机制的人，有点莫名其妙，所以在这里我还是先讲讲sun的jvm的gc机制吧。说到 gc，其实不仅仅只是java的概念，其实在java之前，就有很多语言有gc的概念了，gc嘛就是垃圾收集的意思，更多的是一种算法性的东西，而跟具体 语言没太大关系，所以关于gc的历史，gc的主流算法我就不讲了，那扯得太远了，扯得太远了就是扯淡。sun现在的jvm，内存的管理模型是分代模型，所 以gc当然是分代收集了。分代是什么意思呢？就是将对象按照生命周期分成三个层次，分别是：新生代，旧生代，持久代。对象刚开始分配的时候，大部分都在新 生代，当新生代gc提交被触发后了，执行一次新生代范围内的gc，这叫minor gc，如果执行了几次minor gc后，还有对象存活，将这些对象转入旧生代，因为这些对象已经经过了组织的重重考验了哇。旧生代的gc频率会更低一些，如果旧生代执行了gc，那就是 full gc，因为不是局部gc，而是全内存范围的gc，这会造成应用停顿，因为全内存收集，必须封锁内存，不许有新的对象分配到内存，持久代就是一些jvm期 间，基本不会消失的对象，例如class的定义，jvm方法区信息，例如静态块。需要主要的是，新生代里又分了三个空 间：eden，susvivor0，susvivor1，按字面上来理解，就是伊甸园区，幸存1区，幸存2区。新对象分配在eden区中，eden区满 时，采用标记-复制算法，即检查出eden区存活 的对象，并将这些对象复制到是s0或s1中，然后清空eden区。jvm的gc说开来，不只是这么简单，例如还有串行收集，并行收集，并发收集，还有著名 的火车算法，不过那说得太远了，现在对这个有大致了解就好。说到这里，再来看一下上面输出的信息：</div><div><br></div><div>&nbsp;S0 S1 E O P YGC YGCT FGC FGCT GCT </div><div>&nbsp;54.62 0.00 42.87 43.52 86.24 1792 5.093 33 7.670 12.763</div><div><br></div><div>S0:新生代的susvivor0区，空间使用率为54..62%</div><div><br></div><div>S1:新生代的susvivor1区，空间使用率为0.00%(因为还没有执行第二次minor收集)</div><div><br></div><div>E:eden区，空间使用率42.87%</div><div><br></div><div>O:旧生代，空间使用率43.52%</div><div><br></div><div>P:持久带，空间使用率86.24%</div><div><br></div><div>YGC:minor gc执行次数1792次</div><div><br></div><div>YGCT:minor gc耗费的时间5.093毫秒</div><div><br></div><div>FGC:full gc执行次数33</div><div><br></div><div>FGCT:full gc耗费的时间7.670毫秒</div><div><br></div><div>GCT:gc耗费的总时间12.763毫秒</div><div><br></div><div>*** 怎样选择工具***</div><div><br></div><div>&nbsp;上面列举的一些工具，各有利弊，其实如果在开发环境，使用什么样的工具是无所谓的，只要能得到结果就好。但是在生产环境里，却不能乱选择，因为这些工具本 身就会耗费大量的系统资源，如果在一个生产服务器压力很大的时候，贸然执行这些工具，可能会造成很意外的情况。最好不要在服务器本机监控，远程监控会比较 好一些，但是如果要远程监控，服务器端的启动脚本要加入一些jvm参数，例如用jconsloe远程监控tomcat或jboss等，都需要设置jvm的 jmx参数，如果仅仅只是分析服务器的内存分配和gc信息，强烈推荐，先用jmap导出服务器端的jvm的堆dump文件，然后再用jhat，或者 jvisualvm，或者eclipse内存分析器来分析内存状况。</div><div><br></div><div>### jstat 详解 </div><div><br></div><div>2012-08-28 19:13:50| 分类： [java](http://blog.163.com/yangshuo_qq/blog/#m=0&amp;t=1&amp;c=fks_084070087086081067087094086095086083084071082094086 \"java\") |举报 |字号 [订阅]()</div><div><br></div><div>**jstat**</div><div><br></div><div>&nbsp;1\\. jstat -gc pid</div><div><br></div><div>&nbsp;可以显示gc的信息，查看gc的次数，及时间。</div><div><br></div><div>&nbsp;其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。</div><div><br></div><div>&nbsp;2.jstat -gccapacity pid</div><div><br></div><div>&nbsp;可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，</div><div><br></div><div>&nbsp;如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，</div><div><br></div><div>&nbsp;PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。</div><div><br></div><div>&nbsp;其他的可以根据这个类推， OC是old内纯的占用量。</div><div><br></div><div>&nbsp;3.jstat -gcutil pid</div><div><br></div><div>&nbsp;统计gc信息统计。</div><div><br></div><div>&nbsp;4.jstat -gcnew pid</div><div><br></div><div>&nbsp;年轻代对象的信息。</div><div><br></div><div>&nbsp;5.jstat -gcnewcapacity pid</div><div><br></div><div>&nbsp;年轻代对象的信息及其占用量。</div><div><br></div><div>&nbsp;6.jstat -gcold pid</div><div><br></div><div>&nbsp;old代对象的信息。</div><div><br></div><div>&nbsp;7.stat -gcoldcapacity pid</div><div><br></div><div>&nbsp;old代对象的信息及其占用量。</div><div><br></div><div>&nbsp;8.jstat -gcpermcapacity pid</div><div><br></div><div>&nbsp;perm对象的信息及其占用量。</div><div><br></div><div>&nbsp;9.jstat -class pid</div><div><br></div><div>&nbsp;显示加载class的数量，及所占空间等信息。</div><div>&nbsp;10.jstat -compiler pid</div><div><br></div><div>&nbsp;显示VM实时编译的数量等信息。</div><div><br></div><div>&nbsp;11.stat -printcompilation pid</div><div><br></div><div>&nbsp;当前VM执行的信息。</div><div><br></div><div>&nbsp;一些术语的中文解释：</div><div><br></div><div>&nbsp;S0C：年轻代中第一个survivor（幸存区）的容量 (字节)</div><div>&nbsp;S1C：年轻代中第二个survivor（幸存区）的容量 (字节)</div><div>&nbsp;S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</div><div>&nbsp;S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</div><div>&nbsp;EC：年轻代中Eden（伊甸园）的容量 (字节)</div><div>&nbsp;EU：年轻代中Eden（伊甸园）目前已使用空间 (字节)</div><div>&nbsp;OC：Old代的容量 (字节)</div><div>&nbsp;OU：Old代目前已使用空间 (字节)</div><div>&nbsp;PC：Perm(持久代)的容量 (字节)</div><div>&nbsp;PU：Perm(持久代)目前已使用空间 (字节)</div><div>&nbsp;YGC：从应用程序启动到采样时年轻代中gc次数</div><div>&nbsp;YGCT：从应用程序启动到采样时年轻代中gc所用时间(s)</div><div>&nbsp;FGC：从应用程序启动到采样时old代(全gc)gc次数</div><div>&nbsp;FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s)</div><div>&nbsp;GCT：从应用程序启动到采样时gc用的总时间(s)</div><div><br></div><div>&nbsp;NGCMN：年轻代(young)中初始化(最小)的大小 (字节)</div><div><br></div><div>&nbsp;NGCMX：年轻代(young)的最大容量 (字节)</div><div><br></div><div>&nbsp;NGC：年轻代(young)中当前的容量 (字节)</div><div><br></div><div>&nbsp;OGCMN：old代中初始化(最小)的大小 (字节) </div><div><br></div><div>&nbsp;OGCMX：old代的最大容量 (字节)</div><div><br></div><div>&nbsp;OGC：old代当前新生成的容量 (字节)</div><div><br></div><div>&nbsp;PGCMN：perm代中初始化(最小)的大小 (字节) </div><div><br></div><div>&nbsp;PGCMX：perm代的最大容量 (字节) </div><div><br></div><div>&nbsp;PGC：perm代当前新生成的容量 (字节)</div><div><br></div><div>&nbsp;S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</div><div><br></div><div>&nbsp;S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</div><div><br></div><div>&nbsp;E：年轻代中Eden（伊甸园）已使用的占当前容量百分比</div><div><br></div><div>&nbsp;O：old代已使用的占当前容量百分比</div><div><br></div><div>&nbsp;P：perm代已使用的占当前容量百分比</div><div><br></div><div>&nbsp;S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (字节)</div><div><br></div><div>&nbsp;S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (字节)</div><div><br></div><div>&nbsp;ECMX：年轻代中Eden（伊甸园）的最大容量 (字节)</div><div><br></div><div>&nbsp;DSS：当前需要survivor（幸存区）的容量 (字节)（Eden区已满）</div><div><br></div><div>&nbsp;TT： 持有次数限制</div><div><br></div><div>&nbsp;MTT ： 最大持有次数限制</div><div><br></div><div>&nbsp;sun 官方文档 http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html</div><div><br></div><div>&nbsp;refs:<http://hi.baidu.com/savagert/item/6a056619d25bb6426926bb38></div><div><br></div><div><http://blog.csdn.net/kobejayandy/article/details/8496663></div>"
    }
  ]
}