{
  "title": "DB相关",
  "cells": [
    {
      "type": "text",
      "data": "<h1 id=\"db-\">DB规范</h1>\n<p>为了减少今后出现大量由SQL编写，建表，索引等因素引起的影响到数据库系统稳定性的诸多问题，我们进行了总结归纳，编写了该文档。请所有人员严格执行，违反该规范，进行通报批评。</p>\n<h2 id=\"-\">一.基础规范</h2>\n<p>(1) 使用INNODB存储引擎</p>\n<p>(2) 表字符集使用UTF8或者UTF8mb4</p>\n<p>(3) 建议所有表都需要添加注释</p>\n<p>(4) 不在数据库中存储图，文件等大数据，可以将大对象放到磁盘上，数据库中存储它的路径</p>\n<p>(5) 禁止在线上做数据库压力测试 (可在预发布环境)</p>\n<p>(6) 禁止线下开发环境直连线上数据库主库 (建议)</p>\n<h2 id=\"-\">二.命名规范</h2>\n<p>(1) 库名.表名.字段名必须使用小写字母，\"_\"分割，分表使用后缀为 \"_xx\"，例如\"order_01,order_99\"</p>\n<p>(2) 库名.表名.字段名禁止超过32个字符。须见名知意</p>\n<p>(3) 库名.表名.字段名禁止使用MySQL保留字</p>\n<p>(4) 临时库.表名必须以tmp为前缀，并以日期为后缀</p>\n<p>(5) 备份库.表必须以bak为前缀，并以日期为后缀</p>\n<h2 id=\"-\">三.库.表.字段开发设计规范</h2>\n<p>(1) 按日期时间分表需符合YYYY[MM][DD][HH]格式</p>\n<p>(2) 对日志型表选择分区表策略。</p>\n<p>(3) 建议不使用TEXT.BLOB类型</p>\n<p>(4) 建议所有字段均定义为NOT NULL</p>\n<p>(5) 使用UNSIGNED存储非负整数（存储的范围更大了）</p>\n<p>(6) 使用timestamp存储时间（占用空间更小，4字节， ） Datetime是8个字节 ,create_time 和 update_time 用timestamp, 其他时间列随研发自己（建议）</p>\n<p>(7) 使用INT UNSIGNED存储IPV4</p>\n<p>(8) 建议使用VARBINARY存储大小写敏感的变长字符串</p>\n<p>(9) 禁止在数据库中存储明文密码，把密码加密后存储</p>\n<p>(10) 存储ip最好用int存储而非char(15) 通过MySQL函数inet_ntoa和inet_aton来进行转化。Ipv6地址目前没有转化函数，需要使用DECIMAL或者两个bigINT来存储。</p>\n<p>(11) 不允许使用ENUM （插入非法值的时候，默认会插入一个空值）</p>\n<p>(12) 建议避免使用NULL字段 NULL字段很难查询优化，NULL字段的索引需要额外空间，NULL字段的复合索引无效</p>\n<p>(13) 所有的表必须要有更新时间戳字段且自动更新 (DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP)</p>\n<p>(14)可以适当的添加冗余列,减少表关联，提高查询效率,通过注释表明哪张是主表</p>\n<p>(15) 多表关联导致查询语句性能低下，进行join不超过2个表。（建议）</p>\n<p>(16) 数据库查询语句where条件范围要非常少，不要超过10条记录返回。（建议）</p>\n<p>(17)对表结构多列变更用逗号分隔，而不是写多条变更语句 如 alter table xxx add column name varchar(100) ,modify address varchar(1000),change comment comment varchar(200) CHARACTER SET utf8mb4 ;这样数据库只做一次数据复制，如果写成多条，每变更一次复制一次数据.</p>\n<h2 id=\"-\">四.索引规范</h2>\n<h3 id=\"1-\">1.索引的数量要控制：</h3>\n<p>(1) 单个索引中的字段数不超过5个（建议3个以内）</p>\n<p>(2) 单张表中索引数量不超过5个（建议3个左右）</p>\n<h3 id=\"2-\">2.主键准则</h3>\n<p>(1) 表必须有主键</p>\n<p>(2) 不使用更新频繁的列作为主键</p>\n<p>(3) 尽量不选择字符串列作为主键</p>\n<p>(4) 不允许UUID MD5 HASH这些作为主键</p>\n<p>(5) 默认使用非空的唯一键作为主键</p>\n<p>(6) 建议选择自增</p>\n<h3 id=\"3-sql-\">3.重要的SQL必须被索引，比如：</h3>\n<p>(1) UPDATE.DELETE语句的WHERE条件列</p>\n<p>(2) ORDER BY.GROUP BY.DISTINCT的字段</p>\n<h3 id=\"4-join-join-dba-\">4.多表JOIN的字段注意以下(涉及到多表JOIN的需求,提前提交到DBA处审核)：</h3>\n<p>(1) 区分度最大的字段放在前面</p>\n<p>(2) 核心SQL优先考虑覆盖索引</p>\n<p>(3) 避免冗余和重复索引</p>\n<p>(4) 索引要综合评估数据密度和分布以及考虑查询和更新比例</p>\n<h3 id=\"5-\">5.索引禁忌</h3>\n<p>(1) 不在低基数列上建立索引，例如\"性别\"</p>\n<p>(2) 不在索引列进行数学运算和函数运算</p>\n<h3 id=\"6-\">6.尽量不使用外键</h3>\n<p>(1) 外键用来保护参照完整性，可在业务端实现(踩坑无数)</p>\n<p>(2) 对父表和子表的操作会相互影响，降低可用性</p>\n<h3 id=\"7-idx-_-1-_-2-uniq-_-1-_-2-\">7.索引命名：非唯一索引必须以 idx_字段1_字段2命名，唯一索引必须以uniq_字段1_字段2命名，索引名称必须全部小写</h3>\n<h3 id=\"8-\">8.新建的唯一索引必须不能和主键重复</h3>\n<h3 id=\"9-null-default-null-\">9.索引字段的默认值不能为NULL，要改为其他的default或者空。NULL非常影响索引的查询效率</h3>\n<h3 id=\"10-sql-\">10.反复查看与表相关的SQL，符合最左前缀的特点建立索引。多条字段重复的语句，要修改语句条件字段的顺序，为其建立一条联合索引，减少索引数量</h3>\n<h3 id=\"11-\">11.能使用唯一索引就要使用唯一索引，提高查询效率</h3>\n<h3 id=\"12-explain-sql-extra-using-file-sort-using-temporary\">12.使用EXPLAIN判断SQL语句是否合理使用索引，尽量避免extra列出现：Using File Sort，Using Temporary</h3>\n<h3 id=\"13-sql-dba\">13.SQL变更需要确认索引是否需要变更并通知DBA</h3>\n<h2 id=\"-sql-\">五.SQL规范</h2>\n<p>(1) sql语句尽可能简单,尽力避免使用JOIN</p>\n<p>(2) 事务要简单，整个事务的时间长度不要太长(多事务，小事务原则)</p>\n<p>(3) 避免使用触发器.函数.存储过程</p>\n<p>(4) 避免在数据库中进行数学运算</p>\n<p>(5) 不要用select *，查询哪几个字段就select 这几个字段</p>\n<p>(6) limit分页注意效率。Limit越大，效率越低。可以改写limit，比如例子改写： select id from tlimit 10000, 10; =&gt; select id from t where id &gt; 10000 limit10; SELECT * FROM table ORDER BY TIME DESC LIMIT 10000,10;=》 SELECT * FROM table WHERE TIME\\</p>\n<p>(7) 使用union all替代union</p>\n<p>(8) 避免使用大表的JOIN</p>\n<p>(9) 对数据的更新要打散后批量更新，不要一次更新太多数据，一次每次更新不超过2000条记录</p>\n<p>(10) 减少与数据库的交互次数</p>\n<p>(11) 注意使用性能分析工具 Sql explain / show profile</p>\n<p>(12) SQL语句不可以出现隐式转换，例如 select id from 表 where id='1'</p>\n<p>(13) IN条件里面的数据数量要少,尽量不用</p>\n<p>(14) 能不用NOT IN就不用NOT IN，会把空和NULL给查出来</p>\n<p>(15) 在SQL语句中，禁止使用前缀是%的like</p>\n<p>(16) 不使用负向查询，如not in/like</p>\n<p>(17) 关于分页查询：程序里建议合理使用分页来提高效率limit，offset较大要配合子查询使用</p>\n<p>(18) 禁止在数据库中跑大查询</p>\n<p>(19) 使用预编译语句，只传参数，比传递SQL语句更高效；一次解析，多次使用；降低SQL注入概率</p>\n<p>(20) 禁止使用order by rand()</p>\n<p>(21) 禁止单条SQL语句同时更新多个表</p>\n<p>(22) 禁止子查询中用group by，order by，DISTINCT。例如 (select xx,xxx from a where a.id in (select id from b group by xx)</p>\n<p>(23) 对分区表查询 条件中必须带上分区字段</p>\n<p>(24) 对数据库中的任何数据修改，必须先use db_name 然后再做dml操作。</p>\n<h2 id=\"-\">六.流程规范</h2>\n<p>(1) 发布包必须经过测试人员测试，并且经过压力测试，由测试人员提供，不接受开发人员的发布包</p>\n<p>(2) 所有的建表操作需要提前告知该表涉及的查询sql；(重点关注)</p>\n<p>(3) 所有的建表需要确定建立哪些索引后才可以建表上线；</p>\n<p>(4) 所有的改表结构.加索引操作都需要将涉及到所改表的查询sql发出来告知DBA等相关人员；</p>\n<p>(5) 在建新表加字段之前，建议研发至少要提前一天邮件，给DBA们评估.优化和审核的时间</p>\n<p>(6) 批量导入，导出数据必须提前通知DBA协助观察</p>\n<p>(7) 禁止有super权限的应用程序账号存在</p>\n<p>(8) 推广活动或上线新功能必须提前通知DBA进行流量评估</p>\n<p>(9) 不在业务高峰期批量更新.查询数据库</p>\n<p>(10) 业务高峰期DDL 变更,需要DBA 进行评估，由DBA 决定什么时候进行变更。</p>\n<p>(11) 如版本迭代需要数据库的更新 提前通知DBA （上班时间告知，如果已下班 一定电话通知）</p>\n<p>(12) 数据库慢查询语句，新出现的必须3天内完成整改，历史慢查询必须7天内完成整。</p>\n<p>(13) 应用代码连接数据库配置必须使用阿里开源中间件druid加密。</p>\n<p>(14) 新房和二手房第二个从库提供在线读业务，第三个从库提供离线读业务，,除了新房和二手房外，其他业务主进行读写操作，从库只是作为离线读从库。</p><p><br></p><h1>数据库技术分享第2期：数据库选型</h1><div>一：关系数据库，把数据组织为行，存储在表上，是sql的基础。作为几十年的老产品，每个技术人员必须掌握的技术。关系数据库最大优点是实现ACID（原子性，一致性，隔离性，持久性）原则，一般要求强事务类型业务，都要使用关系数据库存储。典型代表，mysql（开源，要求dba技能高），oracle（功能强悍，收费超级贵）， ms sql server（易用，简单，收费）。</div><div>二：键值数据库，一般是作为缓存层，部分特殊应用可以持久化。Kv数据库典型代表是memcached和redis。Memcached只能做缓存使用，功能简单。redis采用简单动态字符串（SDS）类型，可以做到持久化，例如，新浪微博保存用户关系表，新信息推送都是使用redis存储，没有使用后台关系数据库，目前版本超过150GB单一实例会存在问题。目前从房多多业务来看，配置表，路由表、大并发业务必须加入到缓存中，建议使用redis 3.0。3.0版本官方自带高可用解决方案。</div><div>三：文档类型db，存储使用json格式，适合爬虫，图片，小文件，导流等新型业务。mongodb是代表产品，可以做到分片（shanding），路由，自动切换等高可用。</div><div>四：列式储存，数据存储是按照列存储，区别在于关系数据库是按照行存储。列式db在大批量读取性能高，写入和普通db没有区别，例如，Infobright拥有25：1倍的压缩比存储，这可以对历史表进行压缩，单个实例可以支撑30TB左右。这非常适合数据仓库。开源社区有很多限制，收费版本功能强大。其他列式数据库有SAP HANA、Sybase IQ。</div><div>五：大数据数据库。Hadoop/MapReduce和Spark最适合的都是做离线型的数据分析，但Hadoop特别适合是单次分析的数据量\"很大\"的情景，而Spark则适用于数据量不是很大的情景。这儿所说的\"很大\"，是相对于整个集群中的内存容量而言的，因为Spark是需要将数据保留在内存中。HBase的技术特点上看，它特别适用于简单数据写入（如\"消息类\"应用）和海量、结构简单数据的查询（如\"详单类\"应用）。HBase的另一个用途是作为MapReduce的后台数据源，以支撑离线分析型应用。</div><div>上面1-4是我使用的经验，5是网上查看的</div><p><br></p>\n<h1 id=\"-\">数据库技术分享</h1>\n<h2 id=\"-3-mysql-explain-\">第3期：mysql explain执行计划查看</h2>\n<p>使用explain 对sql进行分析，若是select的话，直接使用，update，delete，insert则需要转化成select语句进行分析。</p>\n<p>下面是显示结果的各个列，会逐一进行解释：</p>\n<p>下面是详细例子：</p>\n<h3 id=\"-id-\">一：Id分析：</h3>\n<p>包含一组数字，表示查询中执行select子句或操作表的顺序</p>\n<p>id相同，执行顺序由上至下</p>\n<p>如果是子查询，id的序号会递增，id值越大优先级越高，优先执行</p>\n<p>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p>\n<h3 id=\"-select-_type-\">二：select_type分析</h3>\n<h3 id=\"-table-\">三：table分析</h3>\n<p>输出记录关联的表，如上面例子的t1,t2,t3,\\</p>\n<h3 id=\"-type-\">四：type分析</h3>\n<p>表关联的方式</p>\n<p><strong>System</strong> 只有一行记录满足要求，特殊的const关联方式</p>\n<p><strong>const </strong>最多只有一行满足要求，where 一般是唯一索引或主键</p>\n<p><strong>eq_ref </strong>从关联的表获取一行记录，除了const外，这是性能最好的关联方式，它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。</p>\n<p><strong>Ref </strong>所有记录都是从索引获取，索引通常不是唯一索引和主键索引</p>\n<h3 id=\"-possible-_keys-\">五：possible_keys分析</h3>\n<p>指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p>\n<h3 id=\"-key-\">六：key分析</h3>\n<p>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL</p>\n<h3 id=\"-key-_len-\">七：key_len分析</h3>\n<p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</p>\n<h3 id=\"-ref-\">八：ref分析</h3>\n<p>表示上述表的连接匹配条件</p>\n<p>即哪些列或常量被用于查找索引列上的值</p>\n<h3 id=\"-rows-\">九：rows分析</h3>\n<p>表示返回的记录数，是优化器从统计信息表获取的。</p>\n<h3 id=\"-extra-\">十：Extra分析</h3>\n<p>using join buffer;使用了连接缓存</p>\n<p>Block Nested Loop，连接算法是块嵌套循环连接</p>\n<p>Batched Key Access，连接算法是批量索引连接</p>\n<p>impossible where; where子句的值总是false，不能用来获取任何元组</p>\n<p>select tables optimized away;基于索引优化MIN/MAX操作,查询执行计划生成的阶段即完成优化。</p>\n<h2 id=\"-4-\">第4期：连接池使用</h2>\n<p>在平时大家沟通时候经常使用到长连接和短连接的说法，现在解释一下。</p>\n<p>长连接是指使用了连接池技术，业务服务器启动的时候，会创建指定的连接数和数据库交互，这些会话一直存在，当前会话内容处理完成后，不会断开，会给下一个事件使用。在数据库上面，会话空闲的状态是Sleep，活跃的状态是Query等。</p>\n<p>短连接就是指应用代码直接连接数据库，没有使用中间件。会话处理完成后，会自动断开连接。</p>\n<p>数据库连接是关键的，昂贵的资源，创建连接，断开连接都是物理操作，消耗非常多物理资源，当应用代码（特别是面对多用户的页面应用）大并发创建的时候，以前在维护oracle的时候，出现每秒150个小时创建连接时，会造成数据库监听端口拥堵，可能出现创建连接延迟。Mysql由于采用分库分表技术，很少单个实例会达到每秒150个创建线程，而且大部分已经使用连接池技术。因此，出现拥堵情况非常少，暂时还没有看到发生。</p>\n<p>目前连接池中间件非常多，例如，java pool，阿里druid，C++开发的连接池等。</p>\n<p>下面是tomcat配置方法：</p>\n<p>将数据库驱动程序的JAR 文件放在Tomcat 的 /lib，配置tomcat 下的conf 下的context.xml 文件</p>\n<p>maxActive=\"20\" 连接池的最大数据库连接数。设为 0 表示无限制</p>\n<p>maxIdle=\"30\" 最大空闲数，数据库连接的最大空闲时间。超过空闲时间，数据库连接将被标记为不可用，然后被释放。设为 0 表示无限制。</p>\n<p>maxWait=\"10000\" 最大建立连接等待时间。如果超过此时间将接到异常。设为 -1 表示无限制。</p>\n<p>下面是druid配置说明：</p>\n<p>initialSize 缺省值 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</p>\n<p>maxActive 缺省值 8 最大连接池数量</p>\n<p>minIdle 缺省值 最小连接池数量</p>\n<p>maxWait 缺省值 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</p><p><br></p><p><br></p><p>数据库技术分享第6期：数据库和服务器关键性能指标</p><p>QPS:Qeury Per Second 每秒查询次数，顾名思义，数据库一秒钟能响应应用服务器查询的次数，该指标体现数据库吞吐能力，一般生产系统oltp单实例的峰值在2万左右，超过3万需要对实例进行扩容或者业务分拆。</p><p>TPS:Transaction Per Second 每秒事务次数，数据库一秒内能处理业务提交事务的次数，操作包含插入，修改，删除操作。一般生产系统oltp业务单实例的峰值在2000左右。可以拆分为Insert Per Second，Update Per Second，Delete Per Second指标。</p><p>数据库连接数是指数据库在某个时刻所有线程数，包括活跃线程和非活跃线程数，一般生产系统oltp业务单实例的峰值在2000左右。若是再大话，会耗费数据库资源，管理每个线程是需要数据库物理资源，增加上下文连接时间。</p><p>活跃线程数是指线程状态不是Sleep状态，一般不要超过50个，该指标耗费极大的cpu，内存，io资源，是最重要的指标，若是经常超过50个，需要对sql进行优化。若是sql是最优的，需要对业务进行分库分表操作，分拆到不同的实例，进行横向扩展。</p><p>非活跃连接数是指线程状态是Sleep状态的线程数。</p><p>数据库慢查询语句耗费所有时间，在一个统计周期内（例如，一天时间），所有超过1秒的查询时间的求和，数据库慢查询语句的个数是不同sql个数相加，相同sql语句，只是更改查询的值，属于同一个sql，只是统计一次。</p><p>数据库服务器资源负载，是指CPU,内存，IO，网卡等资源的使用率，cpu可以通过top，sar –u和sar –d来查看；内存可以通过free –m和vmstat 查看，一般内存使用率不超过90%；io可以通过iostat –x 和iotop来查看，一般使用率不超过90%。网卡通过netstat –i进行查看。由于数据库是io密集类型应用，需要重点关注各个指标。Java等应用服务可以不关注io指标。除了单独监控上面指标外，还可以对load1，load5，load15进行监控，这三个指标是服务综合资源在1分钟内，5分钟内，15分钟内平均负载，若是负载超过15的话，则进行报警。</p>\n"
    }
  ]
}