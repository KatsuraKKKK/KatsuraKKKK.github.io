{
  "title": "JDK源码阅读—基本集合类",
  "cells": [
    {
      "type": "markdown",
      "data": "本文主要为自己在阅读JDK集合类源码的一些笔记，其中涉及java.util包中的集合类型，没有包括java.util.concurrent包。\n\n### Vector \n Vector 实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。Vector 的大小可以根据需要增大或缩小，以适应创建 Vector 后进行添加或移除项的操作。\n每个向量会试图通过维护 capacity 和 capacityIncrement 来优化存储管理。capacity始终至少应与向量的大小相等；这个值通常比后者大些，因为随着将组件添加到向量中，其存储将按 capacityIncrement的大小增加存储。应用程序可以在插入大量组件前增加向量的容量；这样就减少了增加的重分配的量。 它是线程安全的。\n下面是它的扩容相关的方法。\n\n```\nprotected Object[] elementData;\nprotected int capacityIncrement; // 如果不设置，在扩容时翻倍\npublic synchronized void ensureCapacity(int minCapacity) {\n    if (minCapacity > 0) {\n        modCount++;\n        ensureCapacityHelper(minCapacity);\n    }\n}\n\nprivate void ensureCapacityHelper(int minCapacity) {\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0) \n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n### ArrayList\n\nArrayList是List的数组实现，使用数组作为元素存储的数据结构，使用的是一个Object[]。下面是ArrayList数组扩容的方法。\n\n```\nprivate void grow(int minCapacity) {\n  // 下面代码考虑了int的溢出\n  int oldCapacity = elementData.length;\n  int newCapacity = oldCapacity + (oldCapacity >> 1);\n  if (newCapacity - minCapacity < 0)\n  newCapacity = minCapacity;\n  if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n  elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\nprivate static int hugeCapacity(int minCapacity) {\n  if (minCapacity < 0) // overflow\n    throw new OutOfMemoryError();\n  return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;\n}\n```\n\n另外，subList()方法提供的是ArrayList的一个视图，列表的修改冲突使用一个modCount计数器作为判断依据。Iterator中有一个modCount的快照，在修改数组的时候如果快照与modCount不相等说明列表被同时修改了，这时候操会抛出异常。\nArrayList不是线程安全的。\n\n### LinkedList\n\nLinkedList是列表的双向链表实现，在LinkedList中有first，last两个Node的引用，分别是链表的头和尾。\nNode的数据结构如下。\n\n```\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\nLinkedList因为使用的是链表的实现，所以不存在数组扩容的问题，其他的实现与ArrayList类似，只是换成了链表的相关操作。\n下面是获取对应index的节点的操作，还是做了一些优化的：\n\n```\n/**\n * Returns the (non-null) Node at the specified element index.\n */\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n    // 如果index小于size的二分之一则从头遍历，否则从链尾遍历\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\nLinkedList也不是线程安全的。\n\n\n### HashMap\n\nHashMap使用一个Node<K,V>数组作为桶的数据结构。在有元素冲突发生的时候，使用链表和红黑树解决冲突。当一个桶中的元素小于TREEIFY_THRESHHOLD的时候，使用链表处理冲突，否则用将链表转换成红黑树。当桶中的元素个数小于UNTREEIFY_THRESHOLD的时候，将红黑树转换成链表。\n由于红黑树是一种部分平衡的二叉搜索树，这使得在一个桶中元素较多的时候HashMap避免遍历链表，还能有较好的查询性能。\n\n\n```\nstatic final int TREEIFY_THRESHOLD = 8\nstatic final int UNTREEEIFY_THRESHOLD = 6\nstatic final int MIN_TREEIF_CAPACITY = 64\ntransuebt Node<K,N>[] table;\ntransient Set<Map.Entry<K,V>> entrySet;\n//基本的节点类\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n    // ...\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n    // ...\n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n\n/**\n * 对于传入的size，计算能够容纳该size的2的最小次幂，这个神奇的算法在《算法心得》中有提到。\n */\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n/**\n * 元素插入\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        else if (p instanceof TreeNode) // 如果是红黑树节点\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) { // 没有已存在的相等节点\n                    p.next = newNode(hash, key, value, null);\n                    // 是否超过转化成红黑树的阀值\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) // 找到想等节点\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n  }\n\n/**\n * 扩容Map\n */\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                  oldCap >= DEFAULT_INITIAL_CAPACITY) \n            newThr = oldThr << 1; // 原来的两倍\n    } else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                 (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // rehash\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null) // 如果桶中只有一个元素\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode) // 处理红黑树\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    // 这一段处理比较巧妙，用e.hash & oldCap根据oldCap的为1的那一位是否是1来判断该元素是在新的桶数组的前一半还是后一半\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                                loTail = e;\n                            }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                                hiTail = e;\n                            }\n                    } while ((e = next) != null);\n                    // lowHalf 在新桶数组的前一半\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    // highHalf 在新桶数组的后一半\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n  \n另外，在HashMap中的KeySet, Values, EntrySet都只是一个view，遍历通过相应的Iterator进行。HashMap不是线程安全的\n\n### HashTable\n\nHashTable是线程安全的Map实现，使用方法级的synchronized保证线程安全。\n默认的初始化大小是11，size并不是2的幂，与HashMap 的不一样，它也是使用链表法处理冲突。下面是几个关键的操作方法，足以让我们了解HashTable的数据结构操作。\n\n```\n\nprivate transient Entry<?,?>[] table;\n\nprotected void rehash() {\n    int oldCapacity = table.length;\n    Entry<?,?>[] oldMap = table;\n\n    // 考虑了溢出的情况\n    // 新的size是两倍＋1，跟HashMap的不一样\n    int newCapacity = (oldCapacity << 1) + 1;\n    if (newCapacity - MAX_ARRAY_SIZE > 0) {\n        if (oldCapacity == MAX_ARRAY_SIZE)\n            // Keep running with MAX_ARRAY_SIZE buckets\n            return;\n        newCapacity = MAX_ARRAY_SIZE;\n    }\n    Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];\n\n    modCount++;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);\n    table = newMap;\n\n    for (int i = oldCapacity ; i-- > 0 ;) {\n        for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {\n            Entry<K,V> e = old;\n            old = old.next;\n            int index = (e.hash & 0x7FFFFFFF) % newCapacity;\n            e.next = (Entry<K,V>)newMap[index];\n            newMap[index] = e;\n        }\n    }\n}\n\nprivate void addEntry(int hash, K key, V value, int index) {\n    modCount++;\n    Entry<?,?> tab[] = table;\n    if (count >= threshold) {\n        // Rehash the table if the threshold is exceeded\n        rehash();\n        tab = table;\n        hash = key.hashCode();\n        // 这里用了我们常见的取模操作\n        index = (hash & 0x7FFFFFFF) % tab.length;\n    }\n    // Creates the new entry.\n    @SuppressWarnings(\"unchecked\")\n    Entry<K,V> e = (Entry<K,V>) tab[index];\n    tab[index] = new Entry<>(hash, key, value, e);\n    count++;\n}\n    \n@Override\npublic synchronized boolean remove(Object key, Object value) {\n    Objects.requireNonNull(value);\n    Entry<?,?> tab[] = table;\n    int hash = key.hashCode();\n    int index = (hash & 0x7FFFFFFF) % tab.length;\n    @SuppressWarnings(\"unchecked\")\n    Entry<K,V> e = (Entry<K,V>)tab[index];\n    for (Entry<K,V> prev = null; e != null; prev = e, e = e.next) {\n        if ((e.hash == hash) && e.key.equals(key) && e.value.equals(value)) {\n            modCount++;\n            if (prev != null) {\n                prev.next = e.next;\n            } else {\n                tab[index] = e.next;\n            }\n            count--;\n            e.value = null;\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n### ArrayDeque\n\n双端队列Deque接口的数组实现，非线程安全，使用数组作为存储数据结构，可以在使用的时候自动扩容。\n\n```\n\ntransient Object[] elements; // non-private to simplify nested class access \n// 队列头索引\ntransient int head;\n// 队列尾索引\ntransient int tail;\n/**\n  * 又是这个神奇的算法\n  * Allocates empty array to hold the given number of elements.\n  */\nprivate void allocateElements(int numElements) {\n    int initialCapacity = MIN_INITIAL_CAPACITY;\n    // Find the best power of two to hold elements.\n    // Tests \"<=\" because arrays aren't kept full.\n    if (numElements >= initialCapacity) {\n        initialCapacity = numElements;\n        initialCapacity |= (initialCapacity >>>  1);\n        initialCapacity |= (initialCapacity >>>  2);\n        initialCapacity |= (initialCapacity >>>  4);\n        initialCapacity |= (initialCapacity >>>  8);\n        initialCapacity |= (initialCapacity >>> 16);\n        initialCapacity++;\n        if (initialCapacity < 0)   // Too many elements, must back off\n            initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements\n    }\n    elements = new Object[initialCapacity];\n}\n\nprivate void doubleCapacity() {\n    assert head == tail;\n    int p = head;\n    int n = elements.length;\n    int r = n - p; // number of elements to the right of p\n    int newCapacity = n << 1;\n    if (newCapacity < 0)\n        throw new IllegalStateException(\"Sorry, deque too big\");\n    Object[] a = new Object[newCapacity];\n    System.arraycopy(elements, p, a, 0, r);\n    System.arraycopy(elements, 0, a, r, p);\n    elements = a;\n    head = 0;\n    tail = n;\n}\n\n```\n\n对于ArrayDeque的操作，就要看内部类DeqIterator的实现了，以下是部分代码。\n\n```\nprivate class DeqIterator implements Iterator<E> {\n    // 头尾索引\n    private int cursor = head;\n    private int fence = tail;\n\n    // next方法返回的位置, 如果有元素被删除，那么重置为-1\n    private int lastRet = -1;\n\n    public boolean hasNext() {\n        return cursor != fence;\n    }\n\n    public E next() {\n        if (cursor == fence)\n            throw new NoSuchElementException();\n        @SuppressWarnings(\"unchecked\")\n        E result = (E) elements[cursor];\n        if (tail != fence || result == null)\n            throw new ConcurrentModificationException();\n        lastRet = cursor;\n        cursor = (cursor + 1) & (elements.length - 1); // 相当于取模\n        return result;\n    }\n\n    public void remove() {\n        if (lastRet < 0)\n            throw new IllegalStateException();\n        if (delete(lastRet)) { // if left-shifted, undo increment in next()\n            cursor = (cursor - 1) & (elements.length - 1);\n            fence = tail;\n        }\n        lastRet = -1;\n    }\n    /**\n     * 这个方法中注意为尽量少移动元素而进行的优化\n     */ \n    private boolean delete(int i) {\n        checkInvariants();\n        final Object[] elements = this.elements;\n        final int mask = elements.length - 1;\n        final int h = head;\n        final int t = tail;\n        final int front = (i - h) & mask; // i到head的距离\n        final int back  = (t - i) & mask; // i到tail的距离\n        // Invariant: head <= i < tail mod circularity\n        if (front >= ((t - h) & mask))\n            throw new ConcurrentModificationException();\n        // 为尽量少移动元素优化\n        if (front < back) {\n            // 离head比较近\n            if (h <= i) {\n                // 正常情况\n                System.arraycopy(elements, h, elements, h + 1, front);\n            } else { // Wrap around\n                // oioootail****heado这种情况，o表示有元素*表示没有元素\n                System.arraycopy(elements, 0, elements, 1, i);\n                elements[0] = elements[mask];\n                System.arraycopy(elements, h, elements, h + 1, mask - h);\n            }\n            elements[h] = null;\n            head = (h + 1) & mask;\n            return false;\n        } else {\n            // 离head比较远\n            if (i < t) { // Copy the null tail as well\n                System.arraycopy(elements, i + 1, elements, i, back);\n                tail = t - 1;\n            } else { // Wrap around\n                // otail****headooio这种情况，o表示有元素*表示没有元素\n                System.arraycopy(elements, i + 1, elements, i, mask - i);\n                elements[mask] = elements[0];\n                System.arraycopy(elements, 1, elements, 0, t);\n                tail = (t - 1) & mask;\n            }\n            return true;\n        }\n    }\n```\n\n\n### LinkedHashMap\n在Map的实现中，HashMap是无序的。而LinkedHashMap则是有序Map的一种，这个顺序可以是访问顺序或者插入顺序，这个根据构造函数的参数而定，默认是插入顺序。\nLinkedHashMap维护了一个Entry的双向链表，通过重写父类HashMap中的操作后处理方法和TreeNode操作方法来维护链表。\n\n```\nNode<K,V> replacementNode(Node<K,V> p, Node<K,V> next) {\n    // ...\n    transferLinks(q, t);\n    return t;\n}\n\nTreeNode<K,V> newTreeNode(int hash, K key, V value, Node<K,V> next) {\n    // ...\n    linkNodeLast(p);\n    return p;\n}\n\nTreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {\n    // ...\n    transferLinks(q, t);\n    return t;\n}\n\nvoid afterNodeRemoval(Node<K,V> e) { // unlink\n    LinkedHashMap.Entry<K,V> p =\n        (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n    p.before = p.after = null;\n    if (b == null)\n        head = a;\n    else\n        b.after = a;\n    if (a == null)\n        tail = b;\n    else\n        a.before = b;\n}\n\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry<K,V> first;\n    if (evict && (first = head) != null && removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n    LinkedHashMap.Entry<K,V> last;\n    if (accessOrder && (last = tail) != e) {\n        LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n```\n\n### TreeMap\n\n说到有序的Map就不能不提TreeMap了。它是基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。此实现为 containsKey、get、put 和 remove 操作提供受保证的 log(n) 时间开销。这些算法是 Cormen、Leiserson 和 Rivest 的 Introduction to Algorithms 中的算法的改编。\nTreeMap的操作更多是跟红黑树的实现相关，在这里我就不仔细说了（其实我也说不清楚哈哈），详情可以参考红黑树的wiki百科[Red Black Tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)\n\n### WeakHashMap\n\n 以弱键实现的基于哈希表的Map。在WeakHashMap中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的Map实现有所不同。 \n 它将Key关联到一个弱引用，而元素的KV对象Entry继承自WeakReference，并绑定了一个队列，弱引用不影响GC对于Key的回收，当Key被回收以后，Entry会被添加到ReferenceQueue中。\n WakHashMap适合内存敏感的应用场景。\n \n```\n\n/**\n  * Reference queue for cleared WeakEntries\n  */\nprivate final ReferenceQueue<Object> queue = new ReferenceQueue<>();\n\nprivate static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {\n    V value;\n    final int hash;\n    Entry<K,V> next;\n\n    /**\n     * Creates new entry.\n     */\n    Entry(Object key, V value, ReferenceQueue<Object> queue, int hash, Entry<K,V> next) {\n        super(key, queue);  // 调用WeakReference构造函数\n        this.value = value;\n        this.hash  = hash;\n        this.next  = next;\n    }\n}\n\n/**\n * 这个方法将队列中的Node清除\n */\nprivate void expungeStaleEntries() {\n    for (Object x; (x = queue.poll()) != null; ) {\n        synchronized (queue) {\n            @SuppressWarnings(\"unchecked\")\n                Entry<K,V> e = (Entry<K,V>) x;\n            int i = indexFor(e.hash, table.length);\n\n            Entry<K,V> prev = table[i];\n            Entry<K,V> p = prev;\n            while (p != null) {\n                Entry<K,V> next = p.next;\n                if (p == e) {\n                    if (prev == e)\n                        table[i] = next;\n                    else\n                        prev.next = next;\n                    // Must not null out e.next;\n                    // stale entries may be in use by a HashIterator\n                    e.value = null; // Help GC\n                    size--;\n                    break;\n                }\n                prev = p;\n                p = next;\n            }\n        }\n    }\n}\n```\n\n以上，下次估计是要写concurrent包了吧。"
    }
  ]
}