{
  "title": "JVM垃圾回收",
  "cells": [
    {
      "type": "markdown",
      "data": "\n# GC\n\nGC(Garbage Collection)这个概念并不是Java语言锁特有的技术。事实上GC的历史比Java久远，Lisp就才是第一门真正实用内存动态分配和垃圾收集技术的语言。在Java语言中，程序计数器，虚拟机栈，本地方法栈三个区域会随着线程的生命周期结束而得到清理，但是Java堆是动态分配的，垃圾处理器主要关注这部分内存。抽象来说GC要完成的有三件事情：\n\n* 哪些内存需要回收\n* 什么时候回收\n* 如何回收\n\n下面就按照上面三点来仔细说一下GC。\n\n## 哪些内存需要回收\n\n当一个对象再也没有引用可以引用到，那么我们就说它的生命周期可以结束了，那么如何去判断一个对象是否是已经无用了呢。\n\n### 引用计数法\n\n给引用加一个引用计数器，当计数器的数值为0就表示没有其它引用可以引用到这个对象，那么当然这个对象就可以安全的被垃圾回收器所回收。引用计数器实现简单，在大部分情况下它都是一个不错的算法，COM，FlashPlayer，Python等都使用了引用计数法金星内存管理。但是它有一个问题，就是很难解决对象之间的循环引用问题。这就类似于图论中的非连通有向图中的连通分量。\n\n### 可达性分析算法\n\n类似图论中的可达性，以引用为边，以对象为节点。算法的基本思想就是从一系列称为GC Roots的对象作为起始点，从这些节点向下搜索，如果一个节点不可达，则证明这个对象是不可用的，可以被安全的回收掉。在Java语言中，可以作为GC Roots的对象包括以下几种：\n* 虚拟机栈（栈帧中的本地变量表）中引用的对象\n* 方法区中静态类属性引用的对象\n* 方法区中常量引用的对象\n* 本地方法栈中JNI引用的对象\n\n### 四种类型的引用\n  \n再JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用，这四种引用的强度以此减弱。\n* 强引用就是类似\"Object obj = new Object()\"这类的引用。只要强引用存在，垃圾收集器就不会回收调被引用的对象。\n* 软引用是用来描述一些还有用但并非必须的对象。对于软引用关联的对象，再系统将要发生内存溢出之前会把这些对象列进回收范围之中进行二次回收，如果这次还没有足够的内存彩绘抛出内存溢出异常。详情见SoftReference。\n* 弱引用是用来描述非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否足够都会回收被弱引用关联的对象。详情见WeakReference。\n* 虚引用不影响对象的生存\n\n### finalize()方法\n\n### 永久代的回收\n\n### HotSpot虚拟机实现\n\n#### 枚举根节点\n\n#### OopMap\n\n#### 安全点\n\n#### 安全区\n\n#### 垃圾收集器\n\n##### Serial收集器\n\n##### ParNew收集器\n\n##### Parallel收集器\n\n##### ParallelOld收集器\n\n##### GMS收集器\n\n##### G1收集器\n\n\n\n\n\nfinalize()\n  F-Queue, 不会等到方法执行结束，GC稍后会重新标记FQueue，一个对象的finalize方法最多只会执行一次\n\n永久代回收，\n  字面常量\n  废弃的类，三个条件\n  \nhotspot实现\n  枚举根节点 \n    OopMap\n  安全点\n    指令流长时间执行，如方法调用，循环，异常跳转\n    抢先式中断，主动式中断\n  安全区\n\nRemenbered Set\n\n内存分配策略\n\n"
    }
  ]
}