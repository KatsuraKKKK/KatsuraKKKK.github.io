---
layout: post
title: "Java并发编程二三事"
data: 2016-08-16 12:03:30 +0800
category: Database
tags:
- Java
- Concurrency
comments: true
---


# Java并发编程二三事

## 基本组件
### 闭锁
用于线程同步。线程可以堵塞在闭锁的await()方法上，直到countDown()操作将闭锁的计数减少到0。

```
	/**
	 * 闭锁
	 */
	public long countDownLatch() throws InterruptedException {
		int nThreads = 5;
		final CountDownLatch startGate = new CountDownLatch(1);
		final CountDownLatch endGate = new CountDownLatch(nThreads);

		for (int i = 0; i < nThreads; i++) {
			Thread t = new Thread() {
				public void run() {
					try {
						startGate.await();
						sleep(1000);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					endGate.countDown();
				}
			};
			t.start();
		}

		long start = System.nanoTime();
		startGate.countDown();
		endGate.await();
		long end = System.nanoTime();
		return end - start;
	}
```

### FutureTask
可以从新起的工作线程中获取结果，会堵塞在get()方法，直到结果返回或者线程异常终止。下面只是一个简单的实例，实际使用注意处理抛出的异常。

```
	/**
	 * FutureTask
	 */
	public String futureTask() throws ExecutionException, InterruptedException {
		FutureTask<String> future = new FutureTask<>(() -> {
			Thread.currentThread().sleep(3000);
			return "Hello Future.";
		});

		Thread thread = new Thread(future);
		thread.start();
		System.out.println("future.get()");
		return future.get();
	}
```

### 信号量
用于线程的同步，类似PV操作。当计数减少到0的时候acquire()会堵塞，并且直到有其他线程调用release()线程释放信号量或者线程被中断。

```
	/**
	 * Semaphore
	 */
	public void semaphore() {
		Semaphore sem = new Semaphore(1);
		int nThread = 5;
		for (int i = 0; i < nThread; i++) {
			Thread t = new Thread() {
				public void run() {
					try {
						sem.acquire();
						int random = (int) (5 * Math.random());
						sleep(random);
						System.out.println(currentThread().getId());
						sem.release();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			};
			t.start();
		}
	}
```

### 栅栏
与闭锁类似，线程会堵塞在await()方法，直到一定数量的线程到达或者线程被中断。在一定数量的线程到达后，栅栏打开，这批线程可以从堵塞中恢复，然后栅栏再次关闭。

```
	/**
	 * 栅栏
	 * @return
	 * @throws InterruptedException
	 */
	public long cyclicBarrier() throws InterruptedException {
		int nThreads = 25;
		final CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {
			@Override
			public void run() {
				System.out.println("Barrier pass...");
			}
		});

		for (int i = 0; i < nThreads; i++) {
			Thread t = new Thread() {
				public void run() {
					try {
						barrier.await();
						sleep(1000);
					} catch (BrokenBarrierException | InterruptedException e) {
						e.printStackTrace();
					}
				}
			};
			t.start();
		}
	}
```

### CompletionService
作为Executor的包装，主要用来在执行多线程的时候获取返回的执行结果进行处理。至于ExecutorService线程池的种类和相关配置请参考JDK文档。

```
	/**
	 * CompletionService
	 */
	public void completionService() {
		int nThread = 5;
		ExecutorService executor = Executors.newFixedThreadPool(5);
		CompletionService  completionService = new ExecutorCompletionService(executor);

		for (int i = 0; i < nThread; i++) {
			completionService.submit(new Callable<String>() {
				@Override
				public String call() throws Exception {
					if (Thread.currentThread().isInterrupted()) {
						return "interrupted";
					}
					int st = (int)(Math.random() * 5000);
					Thread.sleep(st);
					return Thread.currentThread().getId() + ":" + st;
				}
			});
		}

		for (int i = 0; i < nThread; i++) {
			try {
				Future<String> f = completionService.take();
				System.out.println("Round" + i);
				System.out.println(f.get());
			} catch (InterruptedException | ExecutionException e) {
				e.printStackTrace();
			}

		}
	}
```

### 设定执行时间的任务

下面这个例子只是说明可以这样做，但是并不建议这样处理，因为在非调用线程取消一个线程是一个不太合理的处理方式，最好是让调用者取消，这样调用者还可以进行下一步的处理。
另外这种方式看起来并不优雅。

```
	/**
	 * 取消: 即使任务不响应中断,限时运行的方法仍能够返回到他的调用者。在任务启动以后偶timedRun执行一个限时的join方法,
	 * 在join返回后,将检查是否有异常抛出,有的话再次抛出异常,由于Throwable在两个线程之间共享,所以设置为volatile
	 */
	public void timeRun(final Runnable r) throws Throwable {
		ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(5);
		class  RethrowableTask implements Runnable {
			private volatile Throwable t;
			@Override
			public void run() {
				try {
					r.run();
				} catch (Throwable t) {
					this.t = t;
				}
			}
			void rethrow() throws Throwable {
				if (t != null) {
					throw t;
				}
			}
		}

		RethrowableTask task = new RethrowableTask();
		final Thread taskThread = new Thread(task);
		taskThread.start();
		cancelExec.schedule(() -> taskThread.interrupt(), 100000, TimeUnit.MILLISECONDS);
		taskThread.join(10000);
		task.rethrow();
	}
```

下面是通过Future带时间的get()方法实现的，有时限的任务，可以对比一下，下面这个方式显然要优雅很多。

```
	public void betterTimeRun(Runnable r) throws Throwable {
		ExecutorService executorService = Executors.newFixedThreadPool(5);
		Future<?> task = executorService.submit(r);
		try {
			task.get(10000, TimeUnit.MILLISECONDS);
		} catch (TimeoutException e) {
			// 在finally中被取消
		} catch (ExecutionException e) {
			throw e.getCause();
		} finally {
			task.cancel(true);
		}
	}
```
在try...catch...finally中取消任务。

### UncaughtExcption的处理
Thread的run方法是不抛出非检查异常的，所以外部的try...catch也无法捕获，有时候这会导致一些问题，比如资源没有被释放。

但是我们可以通过Thread的实例方法setUncaughtExceptionHandler去为任何一个线程设置一个UncaughtExceptionHandler。当然也可以调用Thread类的静态方法setUncaughtExceptionHandler去为所有线程设置一个UncaughtExceptionHandler。接口示例如下。

```
	class MyHandler implements Thread.UncaughtExceptionHandler {
		/**
     	* 对于unchecked异常,可以实现UncaughtExceptionHandler接口,当一个线程由于未捕获异常而退出时,JVM会把这个事件告报给应用程序提供的
     	* UncaughtExceptionHandler,如果没有提供任何异常处理器,那么默认的行为是将栈追踪信息输出到System.error
     	*/
    	@Override
    	public void uncaughtException(Thread t, Throwable e) {
			// Do something...
    	}
	}
```

如果没有设置自己的Handler，那么JVM的默认行为是将栈信息输出到System.error。







 [EXPLAIN Statement](http://dev.mysql.com/doc/refman/5.7/en/explain-output.html)

